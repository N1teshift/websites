/**
 * @file Provides functions for **comparing** the values within two mathematical object settings objects.
 * This is primarily intended for testing and evaluation purposes, comparing a known "test" settings object
 * against a "response" settings object (e.g., generated by an LLM).
 * It checks for deep equality of values based on the object type.
 */
import { ObjectType, CoefficientRule, NumberSet, RepresentationType } from "@math/types/mathTypes";
import {
  CoefficientSettings,
  ExpressionSettings,
  EquationSettings,
  CoefficientsSettings,
  TermSettings,
  TermsSettings,
  FunctionSettings,
  PointSettings,
  SetSettings,
  IntervalSettings,
  InequalitySettings,
} from "@math/types/mathObjectSettingsInterfaces";

/**
 * Represents a validation error found during settings comparison.
 */
export interface ValidationError {
  /** Description of the mismatch or error. */
  message: string;
  /** The specific field where the mismatch occurred (if applicable). */
  field?: string;
  /** The index within an array where the mismatch occurred (if applicable). */
  index?: number;
  /** A dot-notation path indicating the location of the error in nested objects (e.g., 'coefficients[0].range'). */
  path?: string;
}

/**
 * Represents the "ground truth" or expected settings object used in comparisons.
 */
export interface TestSettings {
  /** The expected object type. */
  objectType: ObjectType;
  /** The expected settings structure for the object type. */
  settings:
    | CoefficientSettings
    | ExpressionSettings
    | EquationSettings
    | CoefficientsSettings
    | TermSettings
    | TermsSettings
    | FunctionSettings
    | PointSettings
    | SetSettings
    | IntervalSettings
    | InequalitySettings;
}

/**
 * Represents the actual settings object (e.g., from an LLM response) being compared against the `TestSettings`.
 */
export interface ResponseSettings {
  /** The object type of the response object. */
  objectType: ObjectType;
  /** The settings structure of the response object. */
  settings:
    | CoefficientSettings
    | ExpressionSettings
    | EquationSettings
    | CoefficientsSettings
    | TermSettings
    | TermsSettings
    | FunctionSettings
    | PointSettings
    | SetSettings
    | IntervalSettings
    | InequalitySettings;
}

// Validate number set
/** @internal Compares two `NumberSet` values. */
function validateNumberSet(
  testNumberSet: NumberSet,
  responseNumberSet: NumberSet
): ValidationError | null {
  if (testNumberSet !== responseNumberSet) {
    return {
      message: `Number set mismatch: Expected ${testNumberSet}, got ${responseNumberSet}`,
      field: "numberSet",
    };
  }
  return null;
}
// Validate representation type
/** @internal Compares two `RepresentationType` values. */
function validateRepresentationType(
  testRepr: RepresentationType,
  responseRepr: RepresentationType
): ValidationError | null {
  if (testRepr !== responseRepr) {
    return {
      message: `Representation type mismatch: Expected ${testRepr}, got ${responseRepr}`,
      field: "representationType",
    };
  }
  return null;
}
// Validate rules
/** @internal Compares two arrays of `CoefficientRule` values (order insensitive). */
function validateRules(
  testRules: CoefficientRule[],
  responseRules: CoefficientRule[]
): ValidationError | null {
  // Check if arrays have same length
  if (testRules.length !== responseRules.length) {
    return {
      message: `Rules mismatch: Expected ${testRules.length} rules, got ${responseRules.length}`,
      field: "rules",
    };
  }

  // Check if all test rules are present in response rules (order insensitive)
  for (const rule of testRules) {
    if (!responseRules.includes(rule)) {
      return {
        message: `Rules mismatch: Expected rule '${rule}' not found in response`,
        field: "rules",
      };
    }
  }

  return null;
}
// Validate range
/** @internal Compares two range tuples `[number, number]`. */
function validateRange(
  testRange: [number, number],
  responseRange: [number, number]
): ValidationError | null {
  // Ensure we have properly formatted ranges
  const testMin = testRange[0];
  const testMax = testRange[1];
  const responseMin = responseRange[0];
  const responseMax = responseRange[1];

  if (testMin !== responseMin || testMax !== responseMax) {
    return {
      message: `Range mismatch: Expected [${testMin}, ${testMax}], got [${responseMin}, ${responseMax}]`,
      field: "range",
    };
  }
  return null;
}
// Validate string arrays
/** @internal Compares two string arrays (order insensitive). */
function validateStringArray(
  testArray: string[],
  responseArray: string[] | undefined,
  fieldName: string
): ValidationError | null {
  // Check if responseArray is defined and is an array
  if (!responseArray) {
    return {
      message: `${fieldName} missing: Expected an array but got undefined`,
      field: fieldName,
    };
  }

  if (!Array.isArray(responseArray)) {
    return {
      message: `${fieldName} is not an array: Expected array but got ${typeof responseArray}`,
      field: fieldName,
    };
  }

  // Check if arrays have same length
  if (testArray.length !== responseArray.length) {
    return {
      message: `${fieldName} mismatch: Expected ${testArray.length} items, got ${responseArray.length}`,
      field: fieldName,
    };
  }

  // Check if all test items are present in response array (order insensitive)
  for (const item of testArray) {
    if (!responseArray.includes(item)) {
      return {
        message: `${fieldName} mismatch: Expected item '${item}' not found in response`,
        field: fieldName,
      };
    }
  }

  return null;
}
// Validate boolean value
/** @internal Compares two boolean values. */
function validateBoolean(
  testValue: boolean,
  responseValue: boolean,
  fieldName: string
): ValidationError | null {
  if (testValue !== responseValue) {
    return {
      message: `${fieldName} mismatch: Expected ${testValue}, got ${responseValue}`,
      field: fieldName,
    };
  }
  return null;
}
// Validate coefficient settings
/**
 * @internal
 * Compares two `CoefficientSettings` objects field by field.
 * Only compares fields present in the `testSettings`.
 * @returns {ValidationError | null} Null if matching, ValidationError otherwise.
 */
function validateCoefficientSettings(
  testSettings: CoefficientSettings,
  responseSettings: CoefficientSettings
): ValidationError | null {
  // Only check number set if it's defined in the test settings
  if (testSettings.numberSet !== undefined) {
    const numberSetError = validateNumberSet(testSettings.numberSet, responseSettings.numberSet);
    if (numberSetError) return numberSetError;
  }

  // Only check representation type if it's defined in the test settings
  if (testSettings.representationType !== undefined) {
    const reprError = validateRepresentationType(
      testSettings.representationType,
      responseSettings.representationType
    );
    if (reprError) return reprError;
  }

  // Only check rules if they're defined in the test settings
  if (testSettings.rules !== undefined) {
    const rulesError = validateRules(testSettings.rules, responseSettings.rules);
    if (rulesError) return rulesError;
  }

  // Only check range if it's defined in the test settings
  if (testSettings.range !== undefined) {
    // Check range - ensure we have proper tuples
    if (testSettings.range.length !== 2 || responseSettings.range.length !== 2) {
      return {
        message: `Invalid range format: Expected array of length 2`,
        field: "range",
      };
    }

    const testRange: [number, number] = [testSettings.range[0], testSettings.range[1]];
    const responseRange: [number, number] = [responseSettings.range[0], responseSettings.range[1]];

    const rangeError = validateRange(testRange, responseRange);
    if (rangeError) return rangeError;
  }

  // All checks passed
  return null;
}
// Validate coefficients settings
/**
 * @internal
 * Compares two `CoefficientsSettings` objects.
 * Compares `collectionCount`, `rules`, and recursively compares the `coefficients` array.
 * @param {string} [path='coefficients'] - Path prefix for nested errors.
 * @returns {ValidationError | null} Null if matching, ValidationError otherwise.
 */
function validateCoefficientsSettings(
  testSettings: CoefficientsSettings,
  responseSettings: CoefficientsSettings,
  path = "coefficients"
): ValidationError | null {
  // Check collectionCount if defined in test settings
  if (testSettings.collectionCount !== undefined) {
    if (testSettings.collectionCount !== responseSettings.collectionCount) {
      return {
        message: `Coefficients collection count mismatch: Expected ${testSettings.collectionCount}, got ${responseSettings.collectionCount}`,
        field: "collectionCount",
        path,
      };
    }
  }

  // Check coefficientsRules if defined in test settings
  if (testSettings.rules !== undefined) {
    const testRules = Array.isArray(testSettings.rules) ? testSettings.rules : [];
    const responseRules = Array.isArray(responseSettings.rules) ? responseSettings.rules : [];

    const rulesError = validateStringArray(
      testRules as string[],
      responseRules as string[],
      "rules"
    );

    if (rulesError) {
      return {
        ...rulesError,
        path: `${path}.${rulesError.field}`,
      };
    }
  }

  // Check coefficient array if defined in test settings
  if (testSettings.coefficients !== undefined) {
    // Check array length
    if (testSettings.coefficients.length !== responseSettings.coefficients.length) {
      return {
        message: `Coefficients array length mismatch: Expected ${testSettings.coefficients.length}, got ${responseSettings.coefficients.length}`,
        field: "coefficients",
        path,
      };
    }

    // Check each coefficient in the array
    for (let i = 0; i < testSettings.coefficients.length; i++) {
      const coeffError = validateCoefficientSettings(
        testSettings.coefficients[i],
        responseSettings.coefficients[i]
      );

      if (coeffError) {
        return {
          ...coeffError,
          path: `${path}.coefficients[${i}].${coeffError.field}`,
        };
      }
    }
  }

  return null;
}
// Validate term settings
/**
 * @internal
 * Compares two `TermSettings` objects.
 * Compares `termIds`, `power`, `powerOrder`, `variableName`, and recursively compares `coefficients`.
 * @returns {ValidationError | null} Null if matching, ValidationError otherwise.
 */
function validateTermSettings(
  testSettings: TermSettings,
  responseSettings: TermSettings
): ValidationError | null {
  // Validate termIds if defined in test settings
  if (testSettings.termIds !== undefined) {
    const testTermIds = Array.isArray(testSettings.termIds) ? testSettings.termIds : [];
    const responseTermIds = Array.isArray(responseSettings.termIds) ? responseSettings.termIds : [];

    const termIdsError = validateStringArray(testTermIds, responseTermIds, "termIds");
    if (termIdsError) return termIdsError;
  }

  // Validate coefficients if defined in test settings
  if (testSettings.coefficients !== undefined) {
    const coefficientsError = validateCoefficientsSettings(
      testSettings.coefficients,
      responseSettings.coefficients,
      "coefficients"
    );
    if (coefficientsError) return coefficientsError;
  }

  // Validate power range if defined in test settings
  if (testSettings.power !== undefined) {
    if (testSettings.power.length !== 2 || responseSettings.power.length !== 2) {
      return {
        message: `Invalid power range format: Expected array of length 2`,
        field: "power",
      };
    }

    const testPower: [number, number] = [testSettings.power[0], testSettings.power[1]];
    const responsePower: [number, number] = [responseSettings.power[0], responseSettings.power[1]];

    const powerError = validateRange(testPower, responsePower);
    if (powerError) {
      return {
        ...powerError,
        field: "power",
      };
    }
  }

  // Validate powerOrder if defined in test settings
  if (testSettings.powerOrder !== undefined) {
    const powerOrderError = validateBoolean(
      testSettings.powerOrder,
      responseSettings.powerOrder,
      "powerOrder"
    );
    if (powerOrderError) return powerOrderError;
  }

  // Validate variableName if defined in test settings
  if (testSettings.variableName !== undefined) {
    if (testSettings.variableName !== responseSettings.variableName) {
      return {
        message: `Variable name mismatch: Expected ${testSettings.variableName}, got ${responseSettings.variableName}`,
        field: "variableName",
      };
    }
  }

  return null;
}
// Validate terms settings
/**
 * @internal
 * Compares two `TermsSettings` objects.
 * Compares `power`, `powerOrder`, `combinationType`, and recursively compares the `terms` array.
 * @param {string} [path='terms'] - Path prefix for nested errors.
 * @returns {ValidationError | null} Null if matching, ValidationError otherwise.
 */
function validateTermsSettings(
  testSettings: TermsSettings,
  responseSettings: TermsSettings,
  path = "terms"
): ValidationError | null {
  // Validate terms array if defined in test settings
  if (testSettings.terms !== undefined) {
    if (testSettings.terms.length !== responseSettings.terms.length) {
      return {
        message: `Terms array length mismatch: Expected ${testSettings.terms.length}, got ${responseSettings.terms.length}`,
        field: "terms",
        path,
      };
    }

    // Validate each term in the array
    for (let i = 0; i < testSettings.terms.length; i++) {
      const termError = validateTermSettings(testSettings.terms[i], responseSettings.terms[i]);

      if (termError) {
        return {
          ...termError,
          path: `${path}[${i}].${termError.field}`,
        };
      }
    }
  }

  // Validate power range if defined in test settings
  if (testSettings.power !== undefined) {
    if (testSettings.power.length !== 2 || responseSettings.power.length !== 2) {
      return {
        message: `Invalid power range format: Expected array of length 2`,
        field: "power",
        path,
      };
    }

    const testPower: [number, number] = [testSettings.power[0], testSettings.power[1]];
    const responsePower: [number, number] = [responseSettings.power[0], responseSettings.power[1]];

    const powerError = validateRange(testPower, responsePower);
    if (powerError) {
      return {
        ...powerError,
        field: "power",
        path,
      };
    }
  }

  // Validate powerOrder if defined in test settings
  if (testSettings.powerOrder !== undefined) {
    const powerOrderError = validateBoolean(
      testSettings.powerOrder,
      responseSettings.powerOrder,
      "powerOrder"
    );
    if (powerOrderError) {
      return {
        ...powerOrderError,
        path: `${path}.${powerOrderError.field}`,
      };
    }
  }

  // Validate combinationType if defined in test settings
  if (testSettings.combinationType !== undefined) {
    if (testSettings.combinationType !== responseSettings.combinationType) {
      return {
        message: `Combination type mismatch: Expected ${testSettings.combinationType}, got ${responseSettings.combinationType}`,
        field: "combinationType",
        path,
      };
    }
  }

  return null;
}
// Validate expression settings
/**
 * @internal
 * Compares two `ExpressionSettings` objects.
 * Compares `power`, `powerOrder`, `combinationType`, and recursively compares the `expressions` array,
 * determining the type of each element (Term, Terms, or Expression) for correct comparison.
 * @returns {ValidationError | null} Null if matching, ValidationError otherwise.
 */
function validateExpressionSettings(
  testSettings: ExpressionSettings,
  responseSettings: ExpressionSettings
): ValidationError | null {
  // Validate expressions array if defined in test settings
  if (testSettings.expressions !== undefined) {
    if (testSettings.expressions.length !== responseSettings.expressions.length) {
      return {
        message: `Expressions array length mismatch: Expected ${testSettings.expressions.length}, got ${responseSettings.expressions.length}`,
        field: "expressions",
      };
    }

    // Validate each expression in the array
    for (let i = 0; i < testSettings.expressions.length; i++) {
      const testExpr = testSettings.expressions[i];
      const responseExpr = responseSettings.expressions[i];

      // We need to determine what type of object we have
      // Check if it's a TermSettings by checking for termIds property
      if ("termIds" in testExpr && "termIds" in responseExpr) {
        const termError = validateTermSettings(
          testExpr as TermSettings,
          responseExpr as TermSettings
        );

        if (termError) {
          return {
            ...termError,
            path: `expressions[${i}].${termError.field}`,
          };
        }
      }
      // Check if it's a TermsSettings by checking for terms property
      else if ("terms" in testExpr && "terms" in responseExpr) {
        const termsError = validateTermsSettings(
          testExpr as TermsSettings,
          responseExpr as TermsSettings,
          "terms"
        );

        if (termsError) {
          return {
            ...termsError,
            path: `expressions[${i}].${termsError.field}`,
          };
        }
      }
      // Check if it's a nested ExpressionSettings by checking for expressions property
      else if ("expressions" in testExpr && "expressions" in responseExpr) {
        const exprError = validateExpressionSettings(
          testExpr as ExpressionSettings,
          responseExpr as ExpressionSettings
        );

        if (exprError) {
          return {
            ...exprError,
            path: `expressions[${i}].${exprError.field}`,
          };
        }
      }
      // Types don't match - error
      else if (
        ("termIds" in testExpr && !("termIds" in responseExpr)) ||
        ("terms" in testExpr && !("terms" in responseExpr)) ||
        ("expressions" in testExpr && !("expressions" in responseExpr))
      ) {
        return {
          message: `Expression type mismatch at index ${i}`,
          field: "expressions",
          path: `expressions[${i}]`,
        };
      }
    }
  }

  // Validate combinationType if defined in test settings
  if (testSettings.combinationType !== undefined) {
    if (testSettings.combinationType !== responseSettings.combinationType) {
      return {
        message: `Combination type mismatch: Expected ${testSettings.combinationType}, got ${responseSettings.combinationType}`,
        field: "combinationType",
      };
    }
  }

  // Validate power range if defined in test settings
  if (testSettings.power !== undefined) {
    if (testSettings.power.length !== 2 || responseSettings.power.length !== 2) {
      return {
        message: `Invalid power range format: Expected array of length 2`,
        field: "power",
      };
    }

    const testPower: [number, number] = [testSettings.power[0], testSettings.power[1]];
    const responsePower: [number, number] = [responseSettings.power[0], responseSettings.power[1]];

    const powerError = validateRange(testPower, responsePower);
    if (powerError) {
      return {
        ...powerError,
        field: "power",
      };
    }
  }

  // Validate powerOrder if defined in test settings
  if (testSettings.powerOrder !== undefined) {
    const powerOrderError = validateBoolean(
      testSettings.powerOrder,
      responseSettings.powerOrder,
      "powerOrder"
    );
    if (powerOrderError) return powerOrderError;
  }

  return null;
}
// Validate equation settings
/**
 * @internal
 * Compares two `EquationSettings` objects.
 * Recursively compares the `terms` array (expecting ExpressionSettings).
 * @returns {ValidationError | null} Null if matching, ValidationError otherwise.
 * @todo Add comparison logic for fields specific to EquationSettings if any.
 */
function validateEquationSettings(
  testSettings: EquationSettings,
  responseSettings: EquationSettings
): ValidationError | null {
  // Validate terms array if defined in test settings
  if (testSettings.terms !== undefined) {
    if (testSettings.terms.length !== responseSettings.terms.length) {
      return {
        message: `Terms array length mismatch: Expected ${testSettings.terms.length}, got ${responseSettings.terms.length}`,
        field: "terms",
      };
    }

    // Check terms (which are expressions)
    for (let i = 0; i < testSettings.terms.length; i++) {
      const termError = validateExpressionSettings(
        testSettings.terms[i],
        responseSettings.terms[i]
      );

      if (termError) {
        return {
          ...termError,
          path: `terms[${i}].${termError.field}`,
        };
      }
    }
  }

  return null;
}

/**
 * Compares a single `TestSettings` object against a single `ResponseSettings` object.
 * First checks if `objectType` matches, then uses the appropriate internal type-specific
 * comparison function to compare the `settings` values deeply.
 *
 * @param {TestSettings} testSettings The expected/test settings.
 * @param {ResponseSettings} responseSettings The actual/response settings.
 * @returns {ValidationError | null} Returns `null` if the object type and settings match perfectly,
 *                                   otherwise returns a `ValidationError` describing the first mismatch found.
 */
export function validateSettingsMatch(
  testSettings: TestSettings,
  responseSettings: ResponseSettings
): ValidationError | null {
  // First check that object types match
  if (testSettings.objectType !== responseSettings.objectType) {
    return {
      message: `Object type mismatch: Expected ${testSettings.objectType}, got ${responseSettings.objectType}`,
    };
  }

  // Then validate settings based on object type
  switch (testSettings.objectType) {
    case "coefficient":
      return validateCoefficientSettings(
        testSettings.settings as CoefficientSettings,
        responseSettings.settings as CoefficientSettings
      );

    case "coefficients":
      return validateCoefficientsSettings(
        testSettings.settings as CoefficientsSettings,
        responseSettings.settings as CoefficientsSettings
      );

    case "term":
      return validateTermSettings(
        testSettings.settings as TermSettings,
        responseSettings.settings as TermSettings
      );

    case "terms":
      return validateTermsSettings(
        testSettings.settings as TermsSettings,
        responseSettings.settings as TermsSettings
      );

    case "expression":
      return validateExpressionSettings(
        testSettings.settings as ExpressionSettings,
        responseSettings.settings as ExpressionSettings
      );

    case "equation":
      return validateEquationSettings(
        testSettings.settings as EquationSettings,
        responseSettings.settings as EquationSettings
      );

    default:
      return { message: `Unsupported object type: ${testSettings.objectType}` };
  }
}

/**
 * Compares a single `TestSettings` object against an array of `ResponseSettings` objects.
 * Useful when an LLM might return multiple potential objects for a single prompt.
 * It looks for *at least one* response object in the array that perfectly matches the test object.
 *
 * @param {TestSettings} testSettings The expected/test settings.
 * @param {ResponseSettings[]} responseSettingsArray An array of actual/response settings objects.
 * @returns {ValidationError[]} Returns an empty array `[]` if at least one response in the array matches the test settings.
 *                            Otherwise, returns an array containing `ValidationError` objects for each response
 *                            that failed to match (or a generic error if the array was empty).
 */
export function validateSettingsArrayMatch(
  testSettings: TestSettings,
  responseSettingsArray: ResponseSettings[]
): ValidationError[] {
  const errors: ValidationError[] = [];

  responseSettingsArray.forEach((responseSettings, index) => {
    const error = validateSettingsMatch(testSettings, responseSettings);
    if (error) {
      errors.push({
        ...error,
        index,
      });
    }
  });

  return errors;
}

/**
 * General validation function for comparing test case settings against response settings.
 * Handles both single response objects and arrays of response objects.
 *
 * @param {object} testCase An object containing the expected `objectType` and `settings`.
 * @param {ResponseSettings | ResponseSettings[]} responseSettingsData The response data, either a single object or an array.
 * @returns {ValidationError[]} An array of validation errors. Empty if the validation passes
 *                            (i.e., a match is found according to `validateSettingsMatch` or `validateSettingsArrayMatch`).
 */
export function validateResponseSettings(
  // Use a more specific type for testCase, assuming it has objectType and settings
  testCase: { objectType: ObjectType; settings: unknown },
  // Use ResponseSettings or an array of ResponseSettings for the response
  responseSettingsData: ResponseSettings | ResponseSettings[]
): ValidationError[] {
  // Convert test case to TestSettings format
  // Cast testCase.settings to the required union type
  const testSettings: TestSettings = {
    objectType: testCase.objectType,
    settings: testCase.settings as TestSettings["settings"], // Use indexed access type
  };

  // Handle array of settings or single settings object
  if (Array.isArray(responseSettingsData)) {
    // Ensure the array elements match ResponseSettings structure implicitly
    // or add further validation if needed before passing to validateSettingsArrayMatch
    return validateSettingsArrayMatch(testSettings, responseSettingsData);
  } else {
    // responseSettingsData is a single ResponseSettings object
    const error = validateSettingsMatch(testSettings, responseSettingsData);
    return error ? [error] : [];
  }
}
